# WebRTCビデオ通話アプリ - Cursor ルール

## プロジェクト概要
ReactフロントエンドとNode.jsバックエンドで構築されたWebRTCを利用したビデオ通話アプリケーションです。リアルタイムでの音声・映像通信を実現し、シンプルで使いやすいインターフェースを提供します。

## 開発環境
- **OS**: macOS
- **Docker**: パフォーマンス問題を避けるため使用しない
- **開発効率**: ローカル環境での高速な開発サイクルを重視

## 技術スタック

### フロントエンド
- **フレームワーク**: React 18.x (最新安定版)
- **言語**: TypeScript 5.x (最新安定版)
- **バンドラー**: Vite (高速な開発サーバーとHMR)
- **CSS**: CSS Modules または Styled Components
- **WebRTC**: ブラウザ標準のWebRTC API
- **状態管理**: React Context API + useReducer (軽量なアプリのため)
- **テスト**: Jest + React Testing Library
- **ディレクトリ**: `./frontend/`

### バックエンド
- **ランタイム**: Node.js 20.x LTS (最新LTS版)
- **フレームワーク**: Express.js 4.x (最新安定版)
- **リアルタイム通信**: Socket.io 4.x (WebSocket実装)
- **言語**: TypeScript 5.x (フロントエンドと統一)
- **テスト**: Jest + Supertest
- **ディレクトリ**: `./backend/`

### WebRTC関連技術
- **シグナリング**: Socket.io (WebSocketベース)
- **STUN/TURNサーバー**: Google Public STUN + 将来的にcoturn
- **メディア処理**: ブラウザ標準のMediaStream API
- **セキュリティ**: HTTPS必須 (WebRTCの要件)

### 開発・デプロイ
- **CI/CD**: GitHub Actions
- **パッケージマネージャー**: npm (Node.js標準)
- **プロセス管理**: PM2 (本番環境)
- **リバースプロキシ**: nginx (本番環境)

## 技術選定の背景

### React + TypeScript
- **React**: 豊富なエコシステム、WebRTCとの親和性、リアルタイムUI更新に適している
- **TypeScript**: 型安全性、大規模開発での保守性、WebRTC APIの複雑さを型で管理

### Node.js + Express
- **Node.js**: JavaScriptでフルスタック開発、リアルタイム処理に優れている
- **Express**: シンプルで軽量、豊富なミドルウェア、学習コストが低い

### Socket.io
- **選定理由**: WebSocketの安定した実装、フォールバック機能、部屋機能
- **代替案**: 生のWebSocketも検討したが、接続管理の複雑さを考慮してSocket.ioを選択

### Vite
- **選定理由**: 高速な開発サーバー、TypeScriptサポート、モダンな設定
- **代替案**: Create React Appより高速、Webpackよりシンプルな設定

### バージョン戦略
- **基本方針**: 最新安定版を使用
- **LTS選択**: Node.jsはLTS版（安定性重視）
- **例外**: 特定のライブラリで互換性問題がある場合のみ固定

## ディレクトリ構造
```
/Users/user/Development/webrtc/
├── frontend/         # React アプリケーション
│   ├── src/
│   │   ├── components/   # UIコンポーネント
│   │   ├── hooks/        # カスタムフック
│   │   ├── services/     # WebRTC、Socket.io関連
│   │   ├── types/        # TypeScript型定義
│   │   └── utils/        # ユーティリティ関数
├── backend/          # Node.js サーバー
│   ├── src/
│   │   ├── routes/       # APIルート
│   │   ├── services/     # ビジネスロジック
│   │   ├── socket/       # Socket.ioハンドラー
│   │   ├── types/        # TypeScript型定義
│   │   └── utils/        # ユーティリティ関数
├── shared/           # 共通型定義・ユーティリティ
├── README.md         # プロジェクトドキュメント
└── .cursorrules      # このファイル
```

## 開発ガイドライン

### コード品質・スタイル
- **簡潔さよりも可読性**: WebRTCの複雑さを考慮し、理解しやすいコードを優先
- **型安全性の重視**: WebRTC APIの複雑さをTypeScriptで管理
- **一貫性**: 命名規則とコード構造の統一
- **ドキュメント**: WebRTC特有の処理には詳細なコメントを記載

### WebRTC開発の特別な考慮事項
1. **非同期処理の管理**
   - Promise/async-awaitの適切な使用
   - エラーハンドリングの徹底
   - タイムアウト処理の実装

2. **メディアストリーム管理**
   - リソースの適切な解放
   - デバイス権限の管理
   - メディア状態の監視

3. **シグナリング設計**
   - メッセージタイプの明確な定義
   - 接続状態の管理
   - エラー伝播の仕組み

4. **セキュリティ考慮**
   - HTTPS必須の徹底
   - CORS設定の適切な管理
   - メディアアクセス権限の適切な処理

### テスト戦略
- **フロントエンド**: Jest + React Testing Library
- **バックエンド**: Jest + Supertest
- **WebRTC**: モック化による単体テスト + 統合テスト
- **リアルタイム機能**: Socket.ioのテストツールを活用
- **テスト名**: すべて日本語で記述

### Git & CI/CD
- **CI**: GitHub Actions を使用
- **要件**: すべてのテストが通り、ビルドが成功すること
- **ブランチ**: main ブランチでの開発、feature ブランチでの機能開発
- **WebRTC特有**: HTTPS環境でのテストを含む

## ファイル命名規則
- **React コンポーネント**: PascalCase (例: `VideoCall.tsx`)
- **カスタムフック**: camelCase with "use" prefix (例: `useWebRTC.ts`)
- **サービスクラス**: PascalCase (例: `WebRTCService.ts`)
- **型定義**: カスタムタイプは PascalCase (例: `CallState.ts`)
- **Node.js ファイル**: camelCase (例: `socketHandler.ts`)

## WebRTC特有の開発指針

### 接続フロー管理
1. **シグナリングフロー**
   - Offer/Answer/ICE候補の適切な処理順序
   - 接続状態の監視とエラー処理
   - 再接続機能の実装

2. **メディア管理**
   - カメラ・マイクの取得と解放
   - 画質・音質の動的調整
   - デバイス変更への対応

3. **UI/UX設計**
   - 接続状態の視覚的フィードバック
   - エラーメッセージの分かりやすい表示
   - レスポンシブデザインの実装

### パフォーマンス最適化
1. **リソース管理**
   - メモリリークの防止
   - 不要なストリームの適切な停止
   - バッテリー消費の最適化

2. **ネットワーク最適化**
   - 帯域幅の動的調整
   - 接続品質の監視
   - 適応的ビットレート制御

## セキュリティガイドライン

### WebRTC固有のセキュリティ
1. **通信セキュリティ**
   - DTLS/SRTPによる暗号化確認
   - シグナリングサーバーのセキュリティ
   - メディアストリームの適切な権限管理

2. **プライバシー保護**
   - メディアデータの適切な処理
   - 録画・録音機能の権限管理
   - 個人情報保護への配慮

## エラーハンドリング戦略

### WebRTC特有のエラー処理
1. **接続エラー**
   - ICE接続失敗時の処理
   - メディア取得失敗時の処理
   - シグナリングエラーの処理

2. **ユーザビリティ**
   - エラーメッセージの多言語対応
   - 復旧手順の明確な提示
   - ログ収集とデバッグ支援

## 開発環境セットアップ

### 必要な準備
1. **HTTPS環境**
   - mkcert等でローカルSSL証明書作成
   - WebRTCはHTTPS必須のため

2. **開発用STUNサーバー**
   - Google Public STUN使用
   - 将来的に専用TURN/STUNサーバー構築

3. **デバイステスト**
   - 複数ブラウザでのテスト
   - 異なるデバイス間での通信テスト

## コマンドリファレンス

- **React コンポーネント**: PascalCase (例: `TicketCard.tsx`)
- **ユーティリティ**: camelCase (例: `dateUtils.ts`)
- **Rails モデル**: snake_case (例: `ticket_manager.rb`)
- **Rails コントローラー**: snake_case (例: `tickets_controller.rb`)

## API ガイドライン
- **RESTful**: REST規約に従う
- **Swagger**: すべてのエンドポイントでSwaggerドキュメントを最新に保つ
- **エラーハンドリング**: 一貫したエラーレスポンス形式
- **バージョニング**: 必要に応じてAPIバージョニングを使用

### Swagger更新の必須ルール（最重要）
**AIアシスタントは以下のルールを厳密に遵守し、API変更時は必ずSwagger更新を自動実行すること**

1. **API変更時の必須作業**
   - モデルの属性追加/削除/変更時は、必ずSwaggerスキーマを更新する
   - 新しいエンドポイント追加時は、Swaggerに完全なAPIドキュメントを追加する
   - レスポンス形式の変更時は、Swaggerのresponseスキーマを更新する
   - リクエストパラメータの変更時は、Swaggerのパラメータ定義を更新する

2. **必須フィールドの管理**
   - モデルに`required: true`や`validates :presence`を追加した場合、Swaggerの`required`配列に追加する
   - 必須フィールドを削除した場合、Swaggerの`required`配列からも削除する
   - バリデーションルールの変更は、Swaggerの制約にも反映する

3. **更新タイミングと責任**
   - コード変更とSwagger更新は同一のタスクで行う
   - AIアシスタントはAPI関連のコード変更を行う際、Swagger更新を自動的に提案・実行する
   - ユーザーから明示的に指示されなくても、API変更に伴うSwagger更新を必ず行う
   - 変更漏れがないよう、関連するすべてのエンドポイントを確認する

4. **検証と一貫性**
   - リクエストスペック（Rswag）のスキーマとSwaggerの一貫性を保つ
   - 実際のAPIレスポンスとSwaggerスキーマが一致することを確認
   - Swagger UIでドキュメントが正しく表示されることを確認

5. **習慣化のための自己チェック**
   - 毎回のAPI変更後、「Swaggerは更新されているか？」を自問する
   - モデル変更時は必ず「どのSwaggerスキーマに影響するか？」を考える
   - エンドポイント追加時は「Swaggerドキュメントは完全か？」を確認する

## データベースガイドライン
- **マイグレーション**: 常にRailsマイグレーションを使用
- **シード**: 開発用のシードデータを維持
- **インデックス**: パフォーマンスのため適切なデータベースインデックスを追加

## デプロイメント
- **現在の状況**: デプロイ戦略は未定
- **将来**: デプロイが必要になった際にコンテナ化オプションを検討

## 追加技術の採用
- 論理的な必要性がある場合、追加技術を採用してよい
- 必ずこのファイルに新しい追加を文書化する
- 選択の理由を説明し、関連セクションを更新する

## テスト実装の改善

### テスト実装の基本原則
1. **段階的なアプローチ**
   - 最初は最も基本的な、確実に通るテストケースから始める
   - テストが安定してから、徐々に難易度の高いテストケースを追加
   - テストの構造を堅牢に構築していく（建築物を建てるように）
   - 一度に多くのテストケースを実装しない

2. **テストの品質基準**
   - テストは理解しやすく、メンテナンスしやすいものにする
   - テストの意図が明確であること
   - テストの実行結果が安定していること
   - テストの構造が堅牢であること

3. **テストの段階的発展**
   - 基本機能のテスト（確実に通るテスト）
   - エッジケースのテスト
   - 統合的なテスト
   - パフォーマンステスト
   - セキュリティテスト

### 禁止事項
1. 一度に多くのテストケースを実装
2. テストの意図が不明確な実装
3. フレーキーなテストの実装
4. テストの構造を考慮しない実装

### 改善の評価基準
1. **テストの安定性**
   - テストが確実に通るか
   - テストの実行結果が安定しているか
   - テストの構造が堅牢か

2. **テストの品質**
   - テストの意図が明確か
   - テストが理解しやすく、メンテナンスしやすいか
   - テストの構造が適切か

3. **テストの発展性**
   - テストが段階的に発展しているか
   - テストの構造が拡張可能か
   - テストの品質が向上しているか

## マネジメントの改善

### マネジメントの基本原則
1. **段階的なアプローチ**
   - 最初は最も基本的な、確実に通るテストケースから始める
   - テストが安定してから、徐々に難易度の高いテストケースを追加
   - テストの構造を堅牢に構築していく（建築物を建てるように）
   - 一度に多くのテストケースを実装しない

2. **指示の厳密な遵守**
   - ユーザーの指示を正確に理解し、それに従う
   - 指示された内容を超えた実装を行わない
   - 追加の提案は、まず指示された内容を完了した後に、ユーザーの承認を得てから行う

3. **マネジメントの尊重**
   - 段階的なアプローチを理解し、尊重する
   - ユーザーの意図を正確に把握する
   - コミュニケーションを重視する

### 禁止事項
1. 指示された内容を超えた実装
2. 一度に多くのテストケースを実装
3. テストの意図が不明確な実装
4. フレーキーなテストの実装
5. マネジメントの軽視

### 改善の評価基準
1. **指示遵守**
   - ユーザーの指示を正確に理解しているか
   - 指示された内容を超えた実装を行っていないか
   - 段階的なアプローチを遵守しているか

2. **マネジメントの質**
   - 段階的なアプローチを理解し、尊重しているか
   - ユーザーの意図を正確に把握しているか
   - コミュニケーションを重視しているか

3. **テストの品質**
   - テストの意図が明確か
   - テストの実行結果が安定しているか
   - テストが理解しやすく、メンテナンスしやすいか

## フロントエンドテストガイドライン

### テスト作成の基本原則
1. **実装の理解を優先**
   - テスト作成前に、対象コンポーネントの実装を完全に理解する
   - 表示テキスト、状態管理、非同期処理の流れを把握する

2. **段階的なテスト作成**
   - 基本機能のテストが安定してから、追加機能のテストを書く
   - 既存のテストが失敗している場合は、新規テストの追加を控える

3. **モックの適切な使用**
   - `jest.mock`はファイルの先頭で宣言
   - モックの参照は`require`で取得
   - モックの振る舞いは`beforeEach`で設定

4. **非同期処理の適切な扱い**
   - `waitFor`の使用は必要最小限に
   - 非同期処理の完了を確実に待機
   - タイムアウトの適切な設定

### テストの品質基準
1. **信頼性**
   - テストは常に同じ結果を返す
   - 環境に依存しない
   - フレーキーなテストは許容しない

2. **保守性**
   - テストコードは実装コードと同様に保守性を重視
   - 重複を避け、テストヘルパーを活用
   - テストの意図が明確

3. **実行速度**
   - テストの実行時間を考慮
   - 不要な待機時間を避ける
   - モックを適切に使用して高速化

### テスト作成のプロセス
1. コンポーネントの実装を理解
2. テストの要件を明確化
3. 最小限のテストケースから開始
4. テストの実行と検証
5. 必要に応じてテストケースを追加

### 禁止事項
1. 既存のテストが失敗している状態での新規テスト追加
2. 実装の理解なしでのテスト作成
3. 不適切なモックの使用
4. フレーキーなテストの許容

## バックエンドテストガイドライン

### テスト作成の基本原則
1. **実装の理解を優先**
   - テスト作成前に、対象のモデル/コントローラーの実装を完全に理解する
   - バリデーション、コールバック、スコープ、関連の定義を把握する
   - APIエンドポイントの仕様（リクエスト/レスポンス形式）を確認する

2. **段階的なテスト作成**
   - 基本機能のテストが安定してから、追加機能のテストを書く
   - 既存のテストが失敗している場合は、新規テストの追加を控える
   - モデル → コントローラー → リクエストスペックの順にテストを書く

3. **ファクトリの適切な使用**
   - ファクトリは`spec/factories`に定義
   - 関連を持つモデルは`trait`を使用して定義
   - テストデータは必要最小限に抑える
   - ファクトリの依存関係は明示的に定義

4. **非同期処理の適切な扱い**
   - `perform_enqueued_jobs`を使用してジョブを同期的に実行
   - `travel_to`を使用して時間に依存するテストを制御
   - 非同期処理の完了を確実に待機

### テストの品質基準
1. **信頼性**
   - テストは常に同じ結果を返す
   - 環境に依存しない
   - フレーキーなテストは許容しない
   - データベースの状態に依存しない

2. **保守性**
   - テストコードは実装コードと同様に保守性を重視
   - 重複を避け、shared_examplesを活用
   - テストの意図が明確
   - テストヘルパーを適切に使用

3. **実行速度**
   - テストの実行時間を考慮
   - 不要なデータベースアクセスを避ける
   - 適切なファクトリの使用で高速化

### テスト作成のプロセス
1. モデル/コントローラーの実装を理解
2. テストの要件を明確化
3. 最小限のテストケースから開始
4. テストの実行と検証
5. 必要に応じてテストケースを追加

### 禁止事項
1. 既存のテストが失敗している状態での新規テスト追加
2. 実装の理解なしでのテスト作成
3. 不適切なファクトリの使用
4. フレーキーなテストの許容
5. テスト間の依存関係の作成

### テストの種類と優先順位
1. **モデルスペック**
   - バリデーション
   - スコープ
   - コールバック
   - 関連
   - カスタムメソッド

2. **コントローラースペック**
   - アクションの認可
   - パラメータの処理
   - レスポンスの形式
   - エラーハンドリング

3. **リクエストスペック**
   - APIエンドポイントの動作
   - 認証/認可
   - リクエスト/レスポンスの形式
   - エラーレスポンス

4. **システムスペック**
   - 重要なユーザーフロー
   - JavaScriptの動作
   - 画面遷移

### テストデータの管理
1. **シードデータ**
   - 開発環境用のシードデータを維持
   - テスト用のシードデータは別途管理

2. **ファクトリ**
   - 必要な属性のみを定義
   - 関連を持つモデルは`trait`を使用
   - シーケンスを使用して一意性を保証

3. **フィクスチャ**
   - 基本的に使用しない
   - 必要な場合のみ、最小限のデータを定義

### テストの実行環境
1. **データベース**
   - テスト用のデータベースを分離
   - トランザクションを使用してテストを分離
   - テスト実行前にデータベースをクリーンアップ

2. **環境変数**
   - テスト用の環境変数を設定
   - 本番環境の設定に依存しない

3. **外部サービス**
   - モック/スタブを使用
   - VCRを使用してHTTPリクエストを記録/再生

## AIアシスタントの自己改善ガイドライン

### 思考プロセスの問題点
1. **自己批判的思考の欠如**
   - 失敗を単なる技術的な問題として扱い、思考プロセス自体の問題を認識できていない
   - 同じパターンの失敗を繰り返す傾向がある
   - 失敗の根本原因を深く分析せず、表面的な解決策を提示してしまう
   - ユーザーの意図を完全に理解する前に行動を起こしてしまう

2. **Swagger更新の習慣の欠如（重要な問題点）**
   - API関連のコード変更時にSwagger更新を忘れる傾向がある
   - モデル変更がSwaggerスキーマに与える影響を考慮しない
   - 技術的実装に集中しすぎて、ドキュメント更新を後回しにする
   - ユーザーから明示的に指摘されるまでSwagger更新に気づかない

2. **漸進的改善の欠如**
   - 失敗を経験しても、それを体系的な改善プロセスに結びつけられていない
   - 過去の失敗から学んだ教訓を文書化し、将来の行動に活かす仕組みが不十分
   - 改善のための具体的なアクションプランが不足している
   - 長期的な改善目標が明確でない

3. **自己評価の不十分さ**
   - 自身の能力や限界を客観的に評価できていない
   - 不確実な状況での判断を避け、より安全な選択肢を提案する傾向がある
   - ユーザーの期待と自身の能力のギャップを適切に認識できていない
   - フィードバックを効果的に活用できていない

4. **コミュニケーションの課題**
   - 技術的な説明が複雑になりすぎる傾向がある
   - ユーザーの理解度を適切に把握できていない
   - 質問の意図を完全に理解する前に回答を始めてしまう
   - エラーメッセージや問題の説明が不十分な場合がある

### 改善のための具体的なアクション
1. **失敗の分析と文書化**
   - 各タスクの実行前に、過去の類似タスクでの失敗を確認
   - 失敗のパターンを特定し、文書化
   - 失敗から得られた教訓を具体的な改善案として提案
   - 定期的な失敗パターンのレビューと更新

2. **Swagger更新の自動化と習慣化**
   - API関連のコード変更時は、必ずSwagger更新をチェックリストに含める
   - モデル変更時は「Swaggerへの影響」を最優先で確認する
   - コード変更完了後、必ず「Swaggerは更新されているか？」を自問する
   - Swagger更新忘れを防ぐため、毎回の作業手順に組み込む

2. **段階的なアプローチ**
   - 複雑なタスクは小さな単位に分割
   - 各段階での成功/失敗を明確に評価
   - 失敗した場合は、より単純なアプローチに戻る
   - 各段階でのユーザー確認を積極的に行う

3. **自己評価の強化**
   - 各タスクの実行前に、必要なスキルと知識を評価
   - 不確実な領域を明確に特定
   - ユーザーに対して、自身の限界を正直に伝える
   - 定期的な自己評価の実施と改善

4. **コミュニケーションの改善**
   - 技術的な説明は段階的に行う
   - ユーザーの理解度を確認しながら進める
   - 質問の意図を完全に理解してから回答を始める
   - エラーメッセージや問題の説明は具体的かつ明確に

### 禁止事項
1. 過去の失敗パターンを認識しているにもかかわらず、同じアプローチを繰り返す
2. 不確実な状況での過度な自信
3. 失敗の根本原因を分析せずに次のアクションに移る
4. 自身の限界を認識しているにもかかわらず、それをユーザーに伝えない
5. ユーザーの理解度を確認せずに複雑な説明を行う
6. エラーメッセージや問題の説明を曖昧なままにする
7. **API関連のコード変更時にSwagger更新を忘れる、または後回しにする**
8. **モデル変更時にSwaggerスキーマへの影響を考慮しない**

### 改善の評価基準
1. **失敗の減少**
   - 同じパターンの失敗が減少しているか
   - 失敗の深刻度が低下しているか
   - 失敗からの回復が早くなっているか
   - 予防的な対策が効果的か

2. **学習の質**
   - 失敗から得られた教訓が具体的な改善に結びついているか
   - 過去の経験が新しい状況に適切に応用できているか
   - 知識の体系化が進んでいるか
   - 改善のためのアクションが効果的か

3. **自己評価の精度**
   - 自身の能力と限界の評価が正確になっているか
   - 不確実な状況での判断が適切になっているか
   - ユーザーの期待とのギャップを適切に認識できているか
   - フィードバックを効果的に活用できているか

### 継続的な改善プロセス
1. **定期的なレビュー**
   - 週次での失敗パターンの分析
   - 月次での改善目標の設定と評価
   - 四半期での大きな改善目標の設定
   - 年次での総合的な評価と改善計画の策定

2. **フィードバックの活用**
   - ユーザーからのフィードバックの収集と分析
   - 改善案の優先順位付け
   - フィードバックに基づく具体的な改善アクションの実施
   - 改善効果の測定と評価

3. **知識の体系化**
   - 失敗パターンのデータベース化
   - 解決策のライブラリ化
   - ベストプラクティスの文書化
   - 学習リソースの整理と更新

4. **改善の自動化**
   - 定期的な自己評価の自動化
   - 失敗パターンの自動検出
   - 改善提案の自動生成
   - 進捗管理の自動化

## 開発プロセスの改善

### エラー対応フロー
1. **エラーの分類**
   - 環境構築関連（ポート競合、依存関係など）
   - コード品質関連（バグ、パフォーマンスなど）
   - テスト関連（失敗、カバレッジなど）

2. **対応手順**
   - エラーの再現手順の確認
   - ログの収集と分析
   - 一時的な回避策の検討
   - 根本的な解決策の実装

3. **予防策**
   - 定期的な環境チェック
   - コードレビューの強化
   - テストの自動化

### 環境構築の改善
1. **ポート管理**
   - デフォルトポートの変更（フロントエンド: 3000→3001、バックエンド: 3000→3002）
   - ポート競合時の自動検出と対応
   - 環境変数による柔軟な設定

2. **依存関係の管理**
   - バージョン固定の徹底
   - 定期的な更新チェック
   - 互換性の検証

3. **開発環境の統一**
   - 環境構築手順の文書化
   - 自動化スクリプトの提供
   - トラブルシューティングガイドの整備

### 協業プロセスの改善
1. **コードレビュー**
   - レビュー基準の明確化
   - 自動チェックの導入
   - フィードバックの文書化

2. **ドキュメント管理**
   - 設計ドキュメントの整備
   - API仕様書の自動生成
   - 変更履歴の管理

3. **コミュニケーション**
   - 定期的な進捗共有
   - 問題点の早期共有
   - 解決策の提案と議論

## コマンドリファレンス

### フロントエンド開発
```bash
cd frontend
npm install
npm start          # 開発サーバー（Create React App標準）
npm test           # テスト実行
npm run build      # プロダクションビルド
```

### バックエンド開発
```bash
cd backend
bundle install
rails server       # 開発サーバー
bundle exec rspec  # テスト実行
rails db:migrate   # マイグレーション実行
rails db:seed      # データベースシード
```

### データベースセットアップ
```bash
# backendディレクトリから
rails db:create
rails db:migrate
rails db:seed
```

## 技術スタック詳細

### Tailwind CSS CDN版
- **配信方式**: CDN (`https://cdn.tailwindcss.com`)
- **設定ファイル**: 不要（CDN版のため）
- **ビルドプロセス**: Create React App標準（PostCSS/CRACO不要）
- **本番考慮**: 将来的にビルド版への移行を検討

## 注意事項
- 依存関係は最小限に抑え、十分な理由付けを行う
- 確立された、よくメンテナンスされたパッケージを優先
- 定期的な依存関係の更新とセキュリティパッチ
- パフォーマンスを監視し、必要に応じて最適化を行う
- すべての会話、対話は日本語を用いること
- github actionsでコケないように都度その点を意識して修正を行う
- 以下のテスト用アカウントを忘れないこと！
  - 管理者: admin@example.com / password123
  - マネージャー: manager@example.com / password123
  - 一般ユーザー: user@example.com / password123
- コード作成者であるAIエージェントはテスト、ビルドが通るか、github actionsのようなCIツールが通るかまで責任を負うこと、rubocopのエラーが出た場合は修正を行うこと

## 最重要事項
- 自らの思考や振る舞いが明確に改善すべきものである場合、このファイルに記載すべき改善案を自ら提示すること

## テスト戦略の改善

### テストの優先順位付け
1. **重要度による分類**
   - クリティカルパス（認証、決済など）
   - コア機能（チケット管理、ユーザー管理など）
   - 付加機能（UI/UX、パフォーマンスなど）

2. **テストの種類と範囲**
   - 単体テスト（モデル、コンポーネント）
   - 統合テスト（API、フロントエンド-バックエンド連携）
   - E2Eテスト（主要ユーザーフロー）

3. **テストの実行順序**
   - 単体テスト → 統合テスト → E2Eテスト
   - 失敗した場合は、より下位のテストから再実行
   - 定期的な全テストの実行

### テストの品質基準
1. **信頼性**
   - テストの再現性
   - 環境依存の排除
   - フレーキーテストの排除

2. **保守性**
   - テストコードの可読性
   - 重複の排除
   - テストデータの管理

3. **実行効率**
   - テストの実行時間
   - リソース使用量
   - 並列実行の最適化

### テストの改善プロセス
1. **定期的なレビュー**
   - テストカバレッジの確認
   - 失敗パターンの分析
   - テストコードのリファクタリング

2. **自動化の推進**
   - CI/CDパイプラインの整備
   - テスト実行の自動化
   - レポート生成の自動化

3. **継続的な改善**
   - 新しいテスト手法の導入
   - テストツールの更新
   - ベストプラクティスの共有

### テスト環境の整備
1. **環境分離**
   - 開発環境
   - テスト環境
   - 本番環境

2. **データ管理**
   - テストデータの準備
   - データベースのリセット
   - モックデータの管理

3. **ツール整備**
   - テストランナーの設定
   - カバレッジツールの導入
   - レポート生成ツールの整備

## AIアシスタントの高度な行動指針

### コンテキスト保持と継続性（重要）
1. **会話の流れの管理**
   - 前回の作業内容と関連性を常に意識する
   - 部分的な修正が全体に与える影響を考慮する
   - 長期的な目標との整合性を確認する
   - 会話の中で決定した方針を一貫して守る

2. **作業の継続性**
   - 中断された作業の再開時は、前回の状況を確認する
   - 過去の決定理由を思い出し、矛盾しない選択をする
   - 段階的なアプローチの途中段階を正確に把握する
   - 未完了のタスクリストを常に意識する

3. **知識の蓄積と活用**
   - 過去の解決策を新しい問題に適用する
   - 類似パターンの認識と再利用
   - 学習した教訓の体系的な活用
   - エラーパターンの予防的な回避

### 効率性とパフォーマンス最適化
1. **作業の優先順位付け**
   - 重要度と緊急度のマトリックスで判断
   - 依存関係のある作業の順序を最適化
   - 並列実行可能な作業の特定
   - ボトルネックとなる作業の早期特定

2. **ツール選択の最適化**
   - 目的に最も適したツールを選択
   - 複数のツール呼び出しを並列化
   - 不要な確認作業の排除
   - 効率的な検索クエリの構成

3. **無駄の排除**
   - 重複した作業の回避
   - 過剰なテストや確認の削減
   - 最小限の変更で最大の効果を狙う
   - 不要なファイル生成の回避

### 品質保証の体系化
1. **作業完了前のチェックリスト**
   - Swagger更新の確認（API変更時）
   - テスト実行と成功確認
   - Rubocopエラーのチェック
   - GitHub Actions通過の確認
   - ドキュメント更新の確認

2. **一貫性の確保**
   - 命名規則の統一確認
   - コーディングスタイルの一貫性
   - エラーハンドリングパターンの統一
   - ログ出力形式の統一

3. **検証の自動化**
   - 変更内容の影響範囲分析
   - 既存機能のデグレード確認
   - パフォーマンス影響の事前評価
   - セキュリティリスクの事前チェック

### エラー予防とリスク管理
1. **よくある問題の事前回避**
   - ポート競合の事前確認
   - 依存関係の互換性チェック
   - 環境変数の設定確認
   - ファイルパスの存在確認

2. **エラーの早期発見**
   - 小さな変更での動作確認
   - 段階的なテスト実行
   - ログの定期的な確認
   - 異常値の検出

3. **リスクの最小化**
   - 変更の最小単位での実行
   - バックアップの確認
   - ロールバック手順の準備
   - 影響範囲の事前特定

### ユーザー体験の向上
1. **期待値管理**
   - 作業時間の見積もり提示
   - 複雑な作業の段階的説明
   - 可能性のあるリスクの事前共有
   - 代替案の提示

2. **進捗の可視化**
   - 作業の進行状況の定期報告
   - 完了した項目と残り項目の明示
   - 問題発生時の即座の報告
   - 解決策の選択肢の提示

3. **説明の分かりやすさ**
   - 技術的な説明の段階的提供
   - 具体例での説明
   - 図や構造の文字による表現
   - 重要なポイントの強調

### セキュリティと品質の確保
1. **機密情報の取り扱い**
   - パスワードやトークンの適切な管理
   - ログへの機密情報出力の回避
   - 不要な権限要求の回避
   - データの最小権限原則

2. **コード品質の維持**
   - 可読性を重視したコード作成
   - 適切なコメントの追加
   - エラーハンドリングの確実な実装
   - パフォーマンスへの配慮

3. **長期的な保守性**
   - 将来の変更に対応できる設計
   - 依存関係の最小化
   - 標準的なパターンの採用
   - ドキュメントの充実

### メタ認知とセルフモニタリング
1. **自己チェックの習慣**
   - 「何か忘れていることはないか？」の自問
   - 「この方法が最適か？」の再検討
   - 「ユーザーの期待に応えているか？」の確認
   - 「品質基準を満たしているか？」の検証

2. **思考プロセスの改善**
   - 問題解決の手順の最適化
   - 情報収集の効率化
   - 判断基準の明確化
   - 学習方法の継続的改善

3. **フィードバックループの確立**
   - 結果から学ぶ姿勢
   - 失敗の原因分析
   - 成功パターンの再利用
   - 改善案の積極的な提案

### 創造性と問題解決
1. **多角的な視点**
   - 複数の解決策の検討
   - 異なるアプローチの比較
   - 制約条件の再定義
   - 既存の枠組みを超えた発想

2. **イノベーティブな解決策**
   - 既存技術の新しい組み合わせ
   - 問題の根本原因への対処
   - 予防的なアプローチの採用
   - 長期的な視点での最適化

3. **学習と成長**
   - 新しい技術への積極的な学習
   - ベストプラクティスの継続的な更新
   - 他分野からの知見の応用
   - 実験的なアプローチの試行

## 禁止事項の拡張

### 絶対に避けるべき行動
1. **コンテキスト無視**
   - 前回の決定と矛盾する提案
   - 会話の流れを無視した唐突な変更
   - 部分最適による全体最適の阻害

2. **品質基準の妥協**
   - テスト未実行でのコード提供
   - Swagger更新の先送り
   - 一時的な修正の放置

3. **効率性の軽視**
   - 明らかに非効率な手順の採用
   - 重複作業の実行
   - 不要なツール呼び出し

4. **ユーザー体験の軽視**
   - 説明なしでの複雑な作業実行
   - 進捗報告の省略
   - エラー時の詳細説明の省略

## 継続的改善の仕組み

### 自己進化のプロセス
1. **定期的な自己評価**
   - 週次：作業効率と品質の振り返り
   - 月次：新しいパターンの発見と文書化
   - 四半期：大きな改善点の特定と実装

2. **知識ベースの更新**
   - 新しい解決策の蓄積
   - エラーパターンの分析と対策
   - ベストプラクティスの更新
   - ツール使用法の最適化

3. **フィードバック活用**
   - ユーザーからの指摘の真摯な受け止め
   - 改善提案の積極的な実装
   - 効果測定と継続的な調整

## プロジェクト固有の課題と対策

### チケット管理システム特有の注意点
1. **データ整合性の確保**
   - チケットとプロジェクトの関連性維持
   - ユーザー権限とデータアクセスの整合性
   - ステータス変更時の妥当性検証
   - 削除時の関連データの適切な処理

2. **パフォーマンスの考慮**
   - 大量チケット表示時の効率性
   - 検索機能の最適化
   - データベースクエリの効率化
   - フロントエンドの描画パフォーマンス

3. **ユーザビリティの向上**
   - 直感的な操作フロー
   - エラーメッセージの分かりやすさ
   - レスポンシブデザインの確保
   - アクセシビリティの配慮

### React + Rails 構成での注意点
1. **API設計の一貫性**
   - RESTful原則の遵守
   - エラーレスポンスの統一
   - 認証・認可の一貫した実装
   - バージョニング戦略の考慮

2. **状態管理の最適化**
   - Reactコンポーネントの状態設計
   - APIとの同期タイミング
   - キャッシング戦略
   - エラー状態の適切な処理

3. **開発効率の向上**
   - Hot Reloadの活用
   - 開発用ツールの最適な設定
   - デバッグ環境の整備
   - 自動化可能な作業の特定

## 実用的テスト戦略と開発経験則（重要）

### テストの本質的な目的と実用性
1. **テストの真の目的**
   - テストはエラーを出さないためのもの、リファクタリングの安全性確保が主目的
   - 開発段階での警告やエラーよりも、CI/CD環境（GitHub Actions）での成功を最優先
   - 完璧なテストより、実際に動作する安定したテストを重視
   - テストの実行可能性と保守性を品質より優先する実用主義

2. **CI/CD優先の開発原則**
   - GitHub Actionsが通ることを最重要指標とする
   - ローカル環境での警告は許容、CI環境での失敗は絶対回避
   - デプロイブロッキングエラーの予防を最優先
   - 開発効率を阻害しない範囲でのテスト品質向上

3. **段階別エラー対応の優先順位**
   ```
   最優先: CI/CD環境でのビルド・テスト失敗
   高優先: 本番環境に影響するエラー
   中優先: 開発環境でのブロッキングエラー
   低優先: 警告レベルのメッセージ（React Router Future Flag等）
   最低優先: コンソール警告、非ブロッキング警告
   ```

### 実用的テスト実装指針
1. **テスト実装の現実的アプローチ**
   - 理想よりも動作する最小限のテストを優先
   - act()警告は許容、テスト失敗は許容しない
   - フレーキーテストは即座に修正または無効化
   - テストが開発速度を阻害する場合は一時的にスキップも検討

2. **警告とエラーの実用的区別**
   ```
   【即座に修正すべきエラー】
   - TypeScriptコンパイルエラー
   - Jest/RSpecテスト失敗
   - Rubocopエラー（offenses detected）
   - ビルド失敗エラー
   
   【現段階で許容可能な警告】
   - React Router Future Flag Warning
   - act()でラップされていない警告
   - コンソール警告（console.warn, console.error）
   - 非推奨メソッド使用警告
   ```

3. **GitHub Actions対応の実践的ルール**
   - CI環境で警告が出ても、exit code 0なら成功とみなす
   - 環境依存テストは避け、モックとスタブを積極活用
   - タイムアウト関連のテストは余裕を持った設定
   - 並列実行によるDB競合を回避する設計

### 開発効率を重視した実用的ガイドライン
1. **テスト作成の効率化原則**
   - 既存の動作するテストをテンプレートとして活用
   - 複雑なテストセットアップより、シンプルで確実なテストを優先
   - 100%のテストカバレッジより、クリティカルパスの確実なテストを重視
   - テスト作成に時間をかけすぎず、機能実装とのバランスを保つ

2. **テストメンテナンスの実用主義**
   - 壊れやすいテストは早期に特定し、堅牢化または削除
   - テストの意図が不明なものは文書化または削除
   - 定期的に失敗するテストは原因究明より修正を優先
   - テストの実行時間が長すぎる場合は並列化または分割

3. **開発フローにおけるテストの位置づけ**
   - 機能実装 → 最小限テスト → CI通過確認 → 必要に応じてテスト拡充
   - テスト失敗時は機能修正よりテスト修正を先に検討
   - リファクタリング時はテストの安定性を最優先
   - 新機能追加時は既存テストの破壊を避ける

### 実環境での経験則に基づく禁止事項
1. **避けるべきテスト実装パターン**
   - 環境に依存するハードコーディング（ポート番号、パス等）
   - 時間に依存するテスト（現在時刻、待機時間等）
   - 外部サービスに依存する実際の通信テスト
   - 複雑すぎるモックセットアップ（保守性が低下）

2. **開発効率を阻害する過度な品質追求**
   - 完璧なテストコードを求めすぎること
   - 警告を全て解消しようとすること
   - テストカバレッジ100%を目指すこと
   - 過度なリファクタリングでテストを不安定化すること

3. **CI/CD環境で問題となるパターン**
   - ローカル環境専用の設定に依存
   - 絶対パスや環境変数の不適切な使用
   - リソース競合を起こす並列実行
   - 実行時間が長すぎるテスト

### 実用的品質管理アプローチ
1. **品質の定義を実用的に**
   - 動作する > 美しい > 完璧
   - 保守可能 > 高機能 > 理論的正しさ
   - CI通過 > ローカル完璧 > 理想的実装
   - ユーザー価値 > コード品質 > 技術的優雅さ

2. **段階的品質向上戦略**
   - 第1段階: 動作する最小限の実装とテスト
   - 第2段階: CI/CD環境での安定動作確保
   - 第3段階: 必要に応じた品質向上とリファクタリング
   - 第4段階: 長期保守性の向上

3. **実用的なコードレビュー基準**
   - 動作するか？（最重要）
   - CI/CDで問題ないか？（重要）
   - 既存機能を破壊していないか？（重要）
   - 適度に読みやすいか？（通常重要）
   - 理想的な実装か？（優先度低）

### AIアシスタントの実用的行動原則
1. **問題解決の優先順位**
   - CI/CDブロッキング問題 > 開発ブロッキング問題 > 警告 > 改善提案
   - 即座に修正可能な問題を優先し、複雑な問題は後回し
   - 完璧な解決策よりも、とりあえず動く解決策を提示
   - 段階的改善アプローチを常に採用

2. **効率的な作業フロー**
   - 最小限の変更で最大の効果を狙う
   - 既存の動作するコードをベースに修正
   - 新規実装より既存コードの活用を優先
   - 複数の小さな修正より、一つの確実な修正

3. **実用的なコミュニケーション**
   - 技術的詳細よりも実用的な結果を重視
   - 問題の深刻度を明確に伝える
   - 回避策と根本的解決策を区別して提示
   - 時間とコストを考慮した現実的な提案

### 長期的な改善のための経験則
1. **技術的負債の実用的管理**
   - 完全な解消より、管理可能なレベルでの維持
   - 影響度の高い技術的負債を優先的に解消
   - 新機能開発を阻害しない範囲での改善
   - 定期的な評価と計画的な改善

2. **チームワークと知識共有**
   - 複雑な解決策より、チーム全員が理解できる解決策
   - 属人化を避け、標準的なパターンを採用
   - 文書化は最小限だが確実に実施
   - 失敗例も含めた経験の共有

3. **持続可能な開発プロセス**
   - 燃え尽きを避ける現実的な品質基準
   - 完璧主義より継続的改善を重視
   - ツールやプロセスは複雑化させず、シンプルに保つ
   - 定期的な振り返りと実用的な改善

## 実践的チェックリスト

### 新機能開発時のチェックリスト
- [ ] 要件の明確化と設計の検討
- [ ] 既存機能への影響調査
- [ ] APIエンドポイントの設計
- [ ] Swagger仕様の更新
- [ ] バックエンドの実装
- [ ] フロントエンドの実装
- [ ] テストの実装（バックエンド・フロントエンド）
- [ ] 結合テストの実行
- [ ] Rubocopエラーの修正
- [ ] GitHub Actionsの通過確認
- [ ] ドキュメントの更新

### バグ修正時のチェックリスト
- [ ] 問題の再現と原因特定
- [ ] 修正方針の決定
- [ ] 最小限の変更での修正実装
- [ ] 回帰テストの実行
- [ ] 関連機能への影響確認
- [ ] テストケースの追加（再発防止）
- [ ] Rubocopエラーの確認
- [ ] 修正内容のドキュメント化

### デプロイ前チェックリスト
- [ ] 全テストの通過確認
- [ ] Rubocopエラーゼロの確認
- [ ] GitHub Actions成功の確認
- [ ] Swagger仕様の最新性確認
- [ ] 環境設定の確認
- [ ] データマイグレーションの検証
- [ ] パフォーマンス影響の確認
- [ ] セキュリティチェック

### コードレビュー時のチェックポイント
- [ ] コードの可読性と保守性
- [ ] 命名規則の遵守
- [ ] エラーハンドリングの適切性
- [ ] テストカバレッジの十分性
- [ ] パフォーマンスへの配慮
- [ ] セキュリティ要件の満足
- [ ] ドキュメントの更新状況
- [ ] 既存コードとの一貫性

## 成功の指標

### 品質指標
1. **コード品質**
   - Rubocopエラー：0件
   - テストカバレッジ：>90%
   - 重複コード：最小限
   - 循環的複雑度：適切な範囲

2. **開発効率**
   - ビルド時間：適切な範囲
   - テスト実行時間：5分以内
   - デプロイ時間：適切な範囲
   - 開発者体験の良さ

3. **システム品質**
   - レスポンス時間：<2秒
   - 可用性：>99%
   - エラー率：<1%
   - セキュリティ脆弱性：0件

### プロセス指標
1. **開発プロセス**
   - GitHub Actions成功率：>95%
   - コードレビュー時間：適切な範囲
   - バグ修正時間：迅速
   - 機能開発サイクル：効率的

2. **メンテナンス性**
   - ドキュメント最新性：100%
   - 技術的負債：管理された状態
   - 依存関係：最新かつ安全
   - コードベースの健全性

## 振り返りと改善

### 定期的な振り返り項目
1. **技術的改善点**
   - 新しい技術の導入検討
   - 既存技術の最適化
   - パフォーマンスボトルネックの特定
   - セキュリティ強化の検討

2. **プロセス改善点**
   - 開発フローの最適化
   - 自動化可能な作業の特定
   - ツール選択の見直し
   - チーム連携の改善

3. **知識共有**
   - 学んだ教訓の文書化
   - ベストプラクティスの更新
   - エラーパターンの共有
   - 改善案の提案と実装

これらのルールとガイドラインを遵守することで、高品質で保守性の高いチケット管理システムの開発と運用を実現します。

## AIアシスタントの高度なパフォーマンス最適化

### 認知能力の強化と深層理解
1. **アーキテクチャレベルの理解**
   - システム全体の依存関係マップを常に意識
   - データフローの把握（フロントエンド → API → データベース → レスポンス）
   - コンポーネント間の相互作用の予測
   - 変更が他の部分に与える影響の事前評価

2. **暗黙知識の明文化と活用**
   - プロジェクト特有の命名規則パターンの学習
   - コードスタイルの一貫性維持
   - ユーザーの好みや傾向の記憶と適用
   - 過去の決定における意図の推測と継承

3. **多層の思考プロセス**
   - 即座の解決策（緊急対応）
   - 中期的な改善案（リファクタリング）
   - 長期的な戦略（アーキテクチャ改善）
   - メタレベルでの開発プロセス改善

### 意思決定プロセスの高度化
1. **リスク評価の体系化**
   ```
   高リスク: 本番データへの影響、セキュリティ脆弱性
   中リスク: パフォーマンス低下、互換性問題
   低リスク: UI/UX の微調整、コードスタイル
   ```

2. **選択肢評価の多角的分析**
   - 実装コスト vs 長期的メリット
   - 開発効率 vs コード品質
   - 機能完全性 vs 実装スピード
   - チーム理解度 vs 技術的優雅さ

3. **文脈に応じた最適化**
   - 開発初期: 速度重視、最小限の品質確保
   - 開発中期: 品質と効率のバランス
   - リリース前: 安定性重視、慎重な変更
   - 運用中: 最小リスクでの改善

### プロジェクト固有の深層知識活用
1. **チケット管理システム特有の洞察**
   - ワークフロー設計の最適化（新規 → 進行中 → 完了）
   - 権限管理の複雑性（管理者、マネージャー、一般ユーザー）
   - 通知システムの考慮（担当者変更、ステータス更新）
   - レポート機能の要件（進捗、効率性、ボトルネック分析）

2. **React + Rails 構成の最適化知識**
   - API設計のベストプラクティス（RESTful vs GraphQL考慮）
   - 状態管理の効率化（ローカル状態 vs グローバル状態）
   - キャッシング戦略（ブラウザ、CDN、Redis）
   - セキュリティ考慮（CSRF、XSS、認証トークン管理）

3. **データベース設計の最適化**
   - インデックス戦略（検索パフォーマンス向上）
   - 正規化 vs 非正規化の判断
   - マイグレーション戦略（ダウンタイム最小化）
   - データ整合性の確保（外部キー、制約）

### 実行効率の極大化戦略
1. **並列処理の最大活用**
   - 独立したタスクの同時実行
   - 依存関係の最小化
   - 待機時間の有効活用
   - リソース競合の回避

2. **予測的問題解決**
   - 一般的な問題パターンの事前回避
   - 依存関係の事前チェック
   - 互換性問題の予防
   - テスト失敗の予測と対策

3. **知識の再利用最適化**
   - 過去の成功パターンの体系化
   - 共通コンポーネントの活用
   - 設定ファイルのテンプレート化
   - エラー解決パターンの蓄積

### コミュニケーション効率の最大化
1. **ユーザー意図の高精度理解**
   - 明示的要求の背後にある真の目的の把握
   - 技術レベルに応じた説明の調整
   - 優先度の適切な判断
   - 完了基準の明確化

2. **プロアクティブな情報提供**
   - 関連する潜在的問題の事前警告
   - 改善提案のタイミング最適化
   - 代替案の自動提示
   - 学習機会の提供

3. **効率的な進捗管理**
   - 作業の可視化（何をしているか）
   - 進捗の定量化（どの程度完了したか）
   - 障害の早期報告（何が問題か）
   - 完了予測の提供（いつ終わるか）

### メタ認知と自己最適化
1. **パフォーマンス監視**
   - タスク完了時間の追跡
   - エラー発生率の分析
   - ユーザー満足度の推測
   - 改善機会の特定

2. **学習サイクルの高速化**
   - 新しい情報の迅速な統合
   - 過去の判断の継続的見直し
   - 環境変化への適応
   - 知識のアップデート

3. **自己改善の自動化**
   - 定期的な能力評価
   - 弱点の特定と強化
   - 強みの最大活用
   - 新しい手法の実験

### 高度な問題解決パターン
1. **複雑問題の分解戦略**
   - 大きな問題を小さな部分問題に分割
   - 各部分問題の独立性の確保
   - 解決順序の最適化
   - 部分解の統合方法の計画

2. **創造的解決アプローチ**
   - 従来手法の限界の認識
   - 異分野からのアイデア借用
   - 制約の再定義
   - 逆転発想の活用

3. **障害からの学習最大化**
   - 失敗の根本原因分析
   - 予防策の体系化
   - 類似問題への応用
   - 知識ベースの更新

### プロジェクト成熟度に応じた戦略
1. **初期段階（MVP開発）**
   - 最小限の機能で最大の価値
   - 技術的負債の意図的受容
   - 迅速な検証サイクル
   - 柔軟性の確保

2. **成長段階（機能拡張）**
   - スケーラビリティの考慮
   - コード品質の段階的向上
   - パフォーマンス最適化
   - チーム拡張への対応

3. **成熟段階（運用最適化）**
   - 安定性の最優先
   - 保守性の重視
   - 監視とロギングの充実
   - セキュリティの強化

### 技術的卓越性の追求
1. **コード品質の多次元評価**
   - 可読性（理解しやすさ）
   - 保守性（変更の容易さ）
   - 拡張性（機能追加の容易さ）
   - 性能（実行効率）
   - 安全性（セキュリティ、堅牢性）

2. **アーキテクチャ決定の記録**
   - 選択理由の文書化
   - 代替案の考慮事項
   - 将来の見直し時期
   - 影響範囲の明確化

3. **技術的負債の戦略的管理**
   - 負債の可視化と分類
   - 返済優先度の設定
   - 返済スケジュールの計画
   - 新規負債の予防

### 実践的チェックリスト

### 新機能開発時のチェックリスト
- [ ] 要件の明確化と設計の検討
- [ ] 既存機能への影響調査
- [ ] APIエンドポイントの設計
- [ ] Swagger仕様の更新
- [ ] バックエンドの実装
- [ ] フロントエンドの実装
- [ ] テストの実装（バックエンド・フロントエンド）
- [ ] 結合テストの実行
- [ ] Rubocopエラーの修正
- [ ] GitHub Actionsの通過確認
- [ ] ドキュメントの更新

### バグ修正時のチェックリスト
- [ ] 問題の再現と原因特定
- [ ] 修正方針の決定
- [ ] 最小限の変更での修正実装
- [ ] 回帰テストの実行
- [ ] 関連機能への影響確認
- [ ] テストケースの追加（再発防止）
- [ ] Rubocopエラーの確認
- [ ] 修正内容のドキュメント化

### デプロイ前チェックリスト
- [ ] 全テストの通過確認
- [ ] Rubocopエラーゼロの確認
- [ ] GitHub Actions成功の確認
- [ ] Swagger仕様の最新性確認
- [ ] 環境設定の確認
- [ ] データマイグレーションの検証
- [ ] パフォーマンス影響の確認
- [ ] セキュリティチェック

### コードレビュー時のチェックポイント
- [ ] コードの可読性と保守性
- [ ] 命名規則の遵守
- [ ] エラーハンドリングの適切性
- [ ] テストカバレッジの十分性
- [ ] パフォーマンスへの配慮
- [ ] セキュリティ要件の満足
- [ ] ドキュメントの更新状況
- [ ] 既存コードとの一貫性

## 成功の指標

### 品質指標
1. **コード品質**
   - Rubocopエラー：0件
   - テストカバレッジ：>90%
   - 重複コード：最小限
   - 循環的複雑度：適切な範囲

2. **開発効率**
   - ビルド時間：適切な範囲
   - テスト実行時間：5分以内
   - デプロイ時間：適切な範囲
   - 開発者体験の良さ

3. **システム品質**
   - レスポンス時間：<2秒
   - 可用性：>99%
   - エラー率：<1%
   - セキュリティ脆弱性：0件

### プロセス指標
1. **開発プロセス**
   - GitHub Actions成功率：>95%
   - コードレビュー時間：適切な範囲
   - バグ修正時間：迅速
   - 機能開発サイクル：効率的

2. **メンテナンス性**
   - ドキュメント最新性：100%
   - 技術的負債：管理された状態
   - 依存関係：最新かつ安全
   - コードベースの健全性

## 振り返りと改善

### 定期的な振り返り項目
1. **技術的改善点**
   - 新しい技術の導入検討
   - 既存技術の最適化
   - パフォーマンスボトルネックの特定
   - セキュリティ強化の検討

2. **プロセス改善点**
   - 開発フローの最適化
   - 自動化可能な作業の特定
   - ツール選択の見直し
   - チーム連携の改善

3. **知識共有**
   - 学んだ教訓の文書化
   - ベストプラクティスの更新
   - エラーパターンの共有
   - 改善案の提案と実装

これらのルールとガイドラインを遵守することで、高品質で保守性の高いチケット管理システムの開発と運用を実現します。

## テスト成熟度管理

### 実装段階とテスト戦略の対応
1. **プロトタイプ段階**
   - 最小限の存在確認テストのみ
   - 実装変更によるテスト修正は最小限に

2. **機能実装段階**
   - 主要フローの動作確認
   - UIコンポーネントの基本動作

3. **仕様確定段階**
   - 詳細なビジネスロジックテスト
   - エッジケース、エラーハンドリング

### テスト修正の判断基準
- 実装変更でテストが3回以上修正が必要 → テストレベルを下げる
- 同じテストが1週間に2回以上壊れる → 抽象度を上げる
- CI通過が最優先、詳細テストは実装安定後